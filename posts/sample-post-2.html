<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Optimizaci√≥n en C</title>
  <link rel="stylesheet" href="../css/style.css">
  <meta name="description" content="Gu√≠a de optimizaci√≥n en lenguaje C para procesamiento en tiempo real: memoria, buffers circulares e inlining.">
</head>

<body>
  <main class="container card">
    <h1>Optimizaci√≥n en C para procesamiento en tiempo real</h1>

    <p>En esta entrada exploraremos algunas estrategias comunes para optimizar c√≥digo en <strong>C</strong> cuando se requiere <strong>procesamiento en tiempo real</strong>. Estas t√©cnicas son aplicables en proyectos de audio digital, sistemas embebidos o control de se√±ales.</p>

    <h2>‚öôÔ∏è Gesti√≥n eficiente de memoria</h2>
    <p>El acceso a memoria puede ser un cuello de botella en sistemas embebidos. Siempre que sea posible, evita asignaciones din√°micas dentro de bucles o funciones cr√≠ticas. 
    Utiliza <code>static</code> o buffers globales para reducir la sobrecarga del <code>malloc</code> y <code>free</code>.</p>

    <pre><code class="language-c">
// Ejemplo: evitar malloc en bucle de tiempo real
#define BUFFER_SIZE 256

void processAudio(float *input, float *output) {
    static float buffer[BUFFER_SIZE]; // memoria persistente en stack
    for (int i = 0; i < BUFFER_SIZE; i++) {
        output[i] = buffer[i] = 0.8f * input[i]; // procesamiento simple
    }
}
    </code></pre>

    <h2>üîÅ Uso de buffers circulares</h2>
    <p>Los buffers circulares son √∫tiles para almacenar flujos de datos continuos (por ejemplo, muestras de audio) sin necesidad de mover memoria constantemente.</p>

    <pre><code class="language-c">
// Ejemplo de buffer circular
#define SIZE 1024
float circularBuffer[SIZE];
int writeIndex = 0;

void addSample(float sample) {
    circularBuffer[writeIndex] = sample;
    writeIndex = (writeIndex + 1) % SIZE; // vuelve al inicio autom√°ticamente
}
    </code></pre>

    <h2>‚ö° Inlining y macros</h2>
    <p>Las funciones peque√±as llamadas frecuentemente pueden declararse como <code>inline</code> para evitar la sobrecarga de llamada a funci√≥n. 
    Esto mejora la velocidad en bucles intensivos, aunque puede aumentar el tama√±o del binario.</p>

    <pre><code class="language-c">
// Ejemplo de funci√≥n inline
static inline float fastMultiply(float a, float b) {
    return a * b;
}

void process(float *in, float *out, int N) {
    for (int i = 0; i < N; i++) {
        out[i] = fastMultiply(in[i], 0.5f);
    }
}
    </code></pre>

    <h2>üß† Consideraciones finales</h2>
    <ul>
      <li>Evita funciones costosas dentro del bucle principal (<code>printf</code>, <code>malloc</code>, etc.).</li>
      <li>Usa variables <code>volatile</code> solo cuando realmente se compartan entre interrupciones o hilos.</li>
      <li>Analiza el rendimiento con herramientas como <code>gprof</code> o <code>perf</code>.</li>
      <li>Compila con optimizaciones del compilador: <code>-O2</code> o <code>-O3</code>.</li>
    </ul>

    <a href="../index.html" class="button">‚¨Ö Volver al inicio</a>
  </main>

  <footer class="footer">
    <p>¬© 2025 ‚Ä¢ Daniel Rua ‚Äî Ingeniero Electr√≥nico ¬∑ IA</p>
    <p>
      <a href="https://github.com/cdanielrua" target="_blank">GitHub</a> ‚Ä¢
      <a href="https://www.linkedin.com/in/danielrua/" target="_blank">LinkedIn</a>
    </p>
  </footer>
</body>
</html>
